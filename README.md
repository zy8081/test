# 工程方向题目：开发简易版Make工具(minimake)（C语言实现）

## 前言

1. 要求使用操作系统linux,推荐发行版ubuntu,方便上手
    1. 可以考虑wsl(适用于 Linux 的 Windows 子系统文档) 参考文档
    <https://code.visualstudio.com/docs/cpp/config-wsl>
    <https://learn.microsoft.com/zh-cn/windows/wsl/install>
    2. 开发环境搭建参考
    1. <https://code.visualstudio.com/docs/cpp/config-linux>
    3. 可以考虑使用云主机，例如华为云主机，有免费额度，够大家临时用了<https://developer.huaweicloud.com/space/devportal/desktop>
2. 对于已你提交的工程,我们希望可以通过gcc等工具一键编译、运行,有明显的构建入口
3. 请尽量减少使用第三方库,尽量使用标准库和一些系统自带(例如POSIX标准库)的库
4. 如果你没有做完全部题目也完全没有关系,相比于完成度,我们更看重你的学习态度与能力:你需要给出一份学习文档,记录学习过程中你认为的重点和疑点并整理简要文档,但请确保文档上写的知识你完全理解,该文档会作为答辩提问的来源之一
5. 我们编写了自动化测试程序，会以程序的一些输出作为“检查点”，请注意任务中的检查点 ,我们将开源一部分测试样例，来让大家参考
6. 请采用多文件开发实现模块化组织，不要把所有函数放在一个文件里

## 项目背景

理解构建工具的核心原理是提升系统编程能力的重要环节。通过实现简化版Make工具，你将掌握：

- 命令行工具开发范式
- 构建规则解析与执行
- 时间戳比较算法
- 文件依赖关系管理
终极目标,实现构建系统的自举

## 注意事项，请按顺序实现任务，前置任务也是非常重要的考核点

---

### 阶段-1: 版本控制工具git

版本控制工具的核心功能是记录代码的所有修改历史并支持高效协作，它能自动跟踪每次文件变更（包括内容、时间、修改者），允许随时回退到任意历史版本，防止工作成果丢失。
git作为目前最常用的代码版本控制工具,我们要求你使用git管理本次考核的代码,请用git留下你不断迭代的足迹

#### 任务列表

- [ ] 自行查阅资料,学习git的基本用法
- [ ] 建立远程仓库,同步并管理你的代码（gitee或github）
- [ ] 在完成下面的任务时要有历史提交

### 阶段0：知识准备

在该阶段你需要

1. 理解Make工具的核心功能
2. 掌握基础Makefile语法规则
1. 先了解这样简单的语法规则

    ```
    app: main.c utils.c  # 目标: app，依赖: main.c utils.c
        gcc -o app main.c utils.c  # 编译命令
    ```

3. 学习make工具的使用方法
4. 学习C语言编译流程（4个过程）
5. 了解C语言多文件开发方法

### 阶段1：基础框架搭建(难度：★)考点：基础IO与文件操作

目的：创建程序的基本结构，实现命令行交互与简单命令执行  

#### 任务1:命令行参数解析

- 学习使用argc和argv获取用户输入参数  
- 实现命令识别功能（实现--help帮助信息）  
- 要求：能正确处理参数缺失、格式错误等异常情况

##### 检查点

1. 能够识别--help存在，输出里包含字段用法或Usage 包含 --help参数
2. 能够识别不正确的参数，例如--fenihfeihfeiu这样的混乱字段

#### 任务2:预处理与文件读取

- 编写函数使用fopen()和fgets()逐行读取Makefile
- 注意：该函数直接读取当前目录（cwd）下的Makefile，即"./Makefile"
- 预处理流程：
  - 过滤空行（仅包含空白字符的行）
  - 去除行尾空格
  - 去除注释（#后的内容）包括去除注释后的空行和行尾空格
  - 输出清理后的中间结果（可打印处理后的文本）(调试模式,当使用命令行参数-v或--verbose时输出清理后的文本到cwd下的Minimake_claered.mk文件中)

##### 检查点

1. 参考预处理流程中的几个点
2. 注意检查Makefile文件是否存在

#### 任务3:静态语法检查

该阶段Makefile语法仅包含如下内容
该阶段可以有多个目标

```makefile
app: main.c utils.c  # 目标: app，依赖: main.c utils.c(依赖可以不存在)
    gcc -o app main.c utils.c  # 编译命令
    git apply  xxx.patch  # 样例
    echo "success build app"
    #（如上格式存在n个）
```

- 验证基本语法规则：
  - 目标行必须包含冒号分隔符（如target:dep）
  - 命令必须以Tab开头
  - 错误处理：输出带行号的错误信息（"Line5:Missing colon in target definition"）

##### 检查点

1. 错误案例

```makefile
app main.c utils.c  # 目标和依赖之间缺少冒号
    gcc -o app main.c utils.c
```

```txt
Line1: Missing colon in target definition
```

2. 错误案例

```
app:main.c utils.c
    gcc -o app main.c utils.c# 使用了 4 个空格  而不是 `\t`
```

```txt
Line2: Missing colon in target definition
注意   ^这里有空格(这里是把非tab的都不识别为命令)
```

3. 错误案例

```makefile
    gcc -o app main.c utils.c
```

```txt
Line1: Command found before rule
```

---

### 阶段2：解析器开发(难度：★★)考点：字符串与结构体

#### 任务1：规则解析、存储与检查

我们希望你能够在这里实现静态依赖检查,为后续构建依赖图打基础

- 识别目标（target）、依赖（dependencies）和命令（commands）
- 我们保证每个文件名长度不超过32个字符
- 示例解析：
app: main.c utils.c  # 目标: app，依赖: main.c utils.c
    gcc -o app main.c utils.c  # 编译命令
- 要求：构建结构体数组存储解析结果 ，
并检测是否满足规则检查：
  - 禁止重复定义同一目标(案例报错Line4: Duplicate target definition 'app')
  - 依赖文件应存在于当前目录下，也可以是makefile中的其他目标(案例报错Line1: Invalid dependency)

##### 技术要点  

- 设计合理的数据结构
- 实现字符串分割与处理

##### 检查点

1. 案例:目标重复定义

```makefile
app: main.c utils.c
    gcc -o app main.c utils.c

app: main.c utils.c  # 目标 `app` 重复定义
    gcc -o app main.c utils.c
```

报错:

```txt
Duplicate target definition 'app'
```

2. 案例:依赖文件不存在

```makefile
app: main.c utils.c missing.c  # `missing.c` 不存在
    gcc -o app main.c utils.c missing.c
```

报错:

```txt
Invalid dependency 'missing.c'
```

3. 案例:依赖是未定义的目标

```makefile
app: main.c utils.c lib # `lib` 作为依赖，但未在 Makefile 中定义
    gcc -o app main.c utils.c lib
```

报错:

```txt
Invalid dependency 'lib'
```

#### 任务2：进行你的第一次编译

该阶段仅有一个目标
在这个任务中，你需要实现运行命令
请你自行编写一个样例c文件（要求，只包含一个构建目标，只依赖已存在的文件）

##### 案例makefile

```
app: main.c utils.c  # 目标: app，依赖: main.c utils.c
    gcc -o app main.c utils.c  # 编译命令
```

##### 案例使用方法

`minimake app`# 通过第二个参数指定目标

使用你自己编写的minimake来运行你的makefile

##### 检查点

我们会做一些简单的小任务测试你的程序：例如编译一些小东西

---

### 阶段3：依赖关系排序 (难度：★★★)考点：图算法

> 大一同学，可以考虑使用库，对于大二以上同学我们希望能够自行学习相关算法实现(不会做也可以调库)
但是调库也要基本看一下相关的算法思路,建议算法导论22章前4小节
参考链接：
<https://igraph.org/2024/11/06/igraph-0.10.15-c.html>
<https://github.com/igraph/igraph>
<https://igraph.org/c/html/latest/igraph-Installation.html>
我们的测试不会有过于庞大的依赖网络，在实现上可以快速实现优先，性能可以放一放

> PS：可以先做道题练手(对于要自己实现算法的)：<https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked>

#### 任务1：依赖图构建

目标：学习数据结构中的队列、图及相关算法，建立目标（target）与依赖（dependency）之间的依赖关系图

- 任务描述：
  - 设法存储各目标（target）与依赖文件（dependency）之间的依赖关系。
  - 每个目标需要与其依赖文件建立联系，可以通过一个图结构（如邻接矩阵、邻接表）来表示。
  - 为便于下一个任务，构建顶点数组时你可能需要存储各顶点的入度
  - 注意对一些依赖不要遗漏或重复存储

##### 验收标准

- 能够正确地构建每个目标与依赖文件之间的关系。
- 对于各规则（target: dependencies），生成包含所有目标与依赖的图结构，将目标与依赖之间的关系正确存储。
- 支持多重依赖的情况，例如一个目标有多个依赖文件，或一个文件被多个目标依赖。
- 能够输出最后的依赖关系图

#### 任务2：拓扑排序

该阶段无自动化测试
目标：根据依赖关系图确定构建顺序

- 任务描述：
  - 最终目标有且仅有一个(例如minimake target1最终目标是target1)
  - 此处我们暂时保证目标与依赖不会形成循环依赖，即任务1中构建的是一个DAG
  - 对依赖关系图进行拓扑排序，确定构建顺序。
  - 你可能需要了解队列与DAG图的Kahn算法

##### 验收标准

- 能够正确生成拓扑排序，按顺序输出包含依赖的所有文件名，保证所有目标按照正确顺序进行检查与构建。
- （选做）当目标与依赖可能形成循环依赖时，例如，目标 A 依赖于 B， B 依赖于 C，C 又依赖于 A，设法判断并输出报错信息
如果minimake xxx中xxx不存在,要能报错

#### 任务3：时间戳检查

目标：判断目标文件（target）是否满足构建条件及是否需要重新构建

- 任务描述：
  按构建顺序检查目标的依赖文件是否存在于当前目录下，
  - 若目标不存在：
    - 依赖均存在，则对目标进行构建
    - 依赖中有不存在的，按上一阶段的规则检查输出报错信息
    - 确保在处理一个目标时，它的依赖文件已经被处理。
  - 若目标存在：
    - 我们保证其依赖一定均存在
    - 你应该获取目标文件和其依赖文件的修改时间。
    - 比较目标文件与其依赖文件的修改时间，仅在依赖文件比目标文件新的情况下，需要重新构建。

##### 验收标准

- 能够正确判断目标文件是否满足构建条件
- 能够正确地比较文件的修改时间，判断是否需要重新构建。
- 如果依赖文件更新过，对目标文件进行重新构建。
- 如果目标文件已经是最新的，能够避免重复构建。
做到这里,通过之前的system的方式,应该已经能够完成构建系统的自举了

---

### 阶段4：构建执行引擎(难度：★★★)考点：进程

本阶段希望你能够自主实现近似system()接口的功能(有不同,希望你进行思考),建议使用`/bin/sh`执行命令
目的：安全高效地执行编译命令  

#### 任务 1：实现进程控制

同一时间仅需一个子进程就好，本阶段不考虑并行

- 使用 `fork()` 创建子进程
  - minimake 需要为每个命令创建一个子进程，避免阻塞主进程。
- 使用 `execvp()` 在子进程中执行编译命令
  - `execvp()` 允许你执行 gcc 或其他命令，需传递正确的参数数组。(建议使用`/bin/sh`执行命令)
- 使用 `waitpid()` 监控子进程状态
  - `waitpid()` 等待子进程执行完毕，并返回执行结果。

##### 检查点

- 成功创建子进程并在子进程中执行命令。
- 能正确监控子进程的执行状态，并根据状态处理错误。

#### 任务 2：实现错误处理

- 捕获命令执行返回值（使用`WEXITSTATUS()`）
- 实现错误中断机制：任一命令失败立即停止构建

##### 检查点

- 能正确捕获命令的退出状态，并根据状态处理错误。
- 如果某个命令执行失败，能够中断构建并输出错误信息。

##### 技术要点

- 理解Unix进程模型
- 掌握信号处理基础

---

### 阶段5：高级功能实现

#### 任务1：变量替换

你需要了解环境变量表，我们希望你能够通过环境变量表的继承，便捷地完成这个功能。

##### 目标

支持 Makefile 变量定义与动态替换

##### 任务描述

###### 变量解析

- 识别 Makefile 中的变量定义语法（如 `CC = gcc`），提取变量名和值
- 支持变量覆盖：后续定义覆盖同名变量的值（例如 `CFLAGS = -O1` 被 `CFLAGS = -O2` 覆盖）

###### 变量存储

- 使用数据结构（如哈希表）存储变量名与值的映射关系
- 支持多变量共存（如 CC、CFLAGS 等多个独立变量）

###### 变量展开

- 在解析命令时，将 `$(变量名)` 或 `${变量名}` 替换为实际值（例如 `$(CC)` 替换为 `gcc`）
- 支持变量嵌套引用（如 `PATH = $(HOME)/bin`，需递归展开）
- 若变量未定义，替换为空字符串或报错（可自行约定策略）

##### 检查点

1. 正确解析变量定义行，存储并支持后续覆盖（例如 CFLAGS 两次定义后取最后一次的值）
2. 执行命令前完成变量展开（例如 `gcc $(CFLAGS)` 替换为 `gcc -Wall -O2`）
3. 支持变量在依赖列表和命令中的混合使用（如 `app: $(SRC)` 和 `$(CC) -o app $(SRC)`）
4. 处理未定义变量时，程序不崩溃且给出合理行为（如静默忽略或输出警告）

##### 技术要点说明

变量作用域与优先级：

- 变量仅在当前 Makefile 中生效
- 变量定义顺序影响最终值，后续定义覆盖前值

### 阶段6：性能优化（扩展）

难度：★★★★★
考点：并发

#### 目的

提升构建系统效率

#### 任务1：并行构建

在之前的任务基础上完成控制多进程进行编译

##### 要求

- 使用多进程实现并行任务执行
- 控制最大并发数防止资源耗尽
- 确定并发顺序

##### 技术要点

- 理解并发编程基础

##### 检查点

- 有性能提升就行
